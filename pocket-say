#!/bin/bash

# pocket-say: A drop-in replacement for macOS 'say' using Pocket TTS
# Usage: pocket-say [-v voice] [-o output.wav] "message"
# Usage: echo "hello" | pocket-say

# Get the directory where this script is located, resolving symlinks
SOURCE="${BASH_SOURCE[0]}"
while [ -h "$SOURCE" ]; do # resolve $SOURCE until the file is no longer a symlink
  DIR="$( cd -P "$( dirname "$SOURCE" )" && pwd )"
  SOURCE="$(readlink "$SOURCE")"
  [[ $SOURCE != /* ]] && SOURCE="$DIR/$SOURCE" # if $SOURCE was a relative symlink, we need to resolve it relative to the path where the symlink file was located
done
PROJECT_DIR="$( cd -P "$( dirname "$SOURCE" )" && pwd )"

VOICE=""
OUTPUT_FILE=""
TEXT=""
PERSONA=""

# Parse arguments to mimic 'say'
while [[ $# -gt 0 ]]; do
    case $1 in
        -v|--voice)
            VOICE="$2"
            shift 2
            ;;
        --persona)
            PERSONA="$2"
            shift 2
            ;;
        -o|--output-file)
            OUTPUT_FILE="$2"
            shift 2
            ;;
        --version)
            echo "pocket-say version 1.0.0 (Pocket TTS)"
            exit 0
            ;;
        -*)
            # Ignore other say flags for now
            shift
            ;;
        *)
            TEXT="$*"
            break
            ;;
    esac
done

# If VOICE is not set via -v, check .current_voice config
if [ -z "$VOICE" ]; then
    if [ -f "$PROJECT_DIR/.current_voice" ]; then
        VOICE=$(cat "$PROJECT_DIR/.current_voice")
    # Don't set a default voice if a persona is active
    elif [ ! -f "$PROJECT_DIR/.current_persona" ]; then
        VOICE="alba"
    fi
fi

# If PERSONA is not set via --persona, check .current_persona config
if [ -z "$PERSONA" ]; then
    if [ -f "$PROJECT_DIR/.current_persona" ]; then
        PERSONA=$(cat "$PROJECT_DIR/.current_persona")
    fi
fi

# DEBUG LOGGING
echo "[$(date)] Speaking: $TEXT (Voice: $VOICE)" >> "$PROJECT_DIR/pocket_say.log"

# Handle STDIN if TEXT is empty
if [ -z "$TEXT" ]; then
    if [ ! -t 0 ]; then
        TEXT=$(cat)
    fi
fi

if [ -z "$TEXT" ]; then
    exit 0
fi

# Use a temporary file if we're playing audio
PLAY_AUDIO=true
if [ -n "$OUTPUT_FILE" ]; then
    PLAY_AUDIO=false
    TEMP_WAV="$OUTPUT_FILE"
else
    TEMP_WAV=$(mktemp /tmp/pocket_tts_XXXXXX)
    mv "$TEMP_WAV" "${TEMP_WAV}.wav"
    TEMP_WAV="${TEMP_WAV}.wav"
fi

# Ensure server is running or fallback to slow mode?
# For now, we assume the user has the server running via the Menu Bar app or start_server.sh
# Check health
if ! curl -s "http://localhost:8000/health" > /dev/null; then
    # Fallback: Start server automatically or use direct CLI?
    # Direct CLI is slow because it loads the model every time.
    # Let's try to start it if it's not running.
    "$PROJECT_DIR/scripts/start_server.sh" > /dev/null 2>&1
fi

CURL_DATA_ARGS=()
CURL_DATA_ARGS+=(--data-urlencode "text=$TEXT")
if [ -n "$VOICE" ]; then
    CURL_DATA_ARGS+=(--data-urlencode "voice_url=$VOICE")
fi
if [ -n "$PERSONA" ]; then
    CURL_DATA_ARGS+=(--data-urlencode "persona=$PERSONA")
fi

# Hit the local server
echo "CURL ARGS: ${CURL_DATA_ARGS[@]}" >> "$PROJECT_DIR/pocket_say.log"
# Hit the local server - separate status logging from file output
HTTP_STATUS=$(curl -s -X POST "http://localhost:8000/tts" \
     -H "Content-Type: application/x-www-form-urlencoded" \
     "${CURL_DATA_ARGS[@]}" \
     --output "$TEMP_WAV" \
     -w "%{http_code}")

echo "HTTP status: $HTTP_STATUS" >> "$PROJECT_DIR/pocket_say.log"


EXIT_CODE=0
if [ "$PLAY_AUDIO" = true ]; then
    echo "PLAY_AUDIO is true" >> "$PROJECT_DIR/pocket_say.log"
    if [ -s "$TEMP_WAV" ]; then
        echo "TEMP_WAV is not empty" >> "$PROJECT_DIR/pocket_say.log"
        SHOULD_PLAY=true
        
        # Check if muted
        if [ -f "$PROJECT_DIR/.muted" ]; then
            echo "Muted, SHOULD_PLAY is false" >> "$PROJECT_DIR/pocket_say.log"
            SHOULD_PLAY=false
        fi

        if [ "$SHOULD_PLAY" = true ] && [ -f "$PROJECT_DIR/.headphones_only" ]; then
            echo "Headphones only is true" >> "$PROJECT_DIR/pocket_say.log"
            # Check if headphones are connected
            OUTPUT_INFO=$(system_profiler SPAudioDataType | grep -B 10 "Default Output Device: Yes")
            echo "OUTPUT_INFO: $OUTPUT_INFO" >> "$PROJECT_DIR/pocket_say.log"
            
            # Default to not playing if Headphones Only is on
            SHOULD_PLAY=false
            
            # Allow if it's explicitly Headphones or Bluetooth
            if echo "$OUTPUT_INFO" | grep -Ei "Headphone|Bluetooth|AirPod|Buds|Headset" > /dev/null; then
                echo "Headphones detected, SHOULD_PLAY is true" >> "$PROJECT_DIR/pocket_say.log"
                SHOULD_PLAY=true
            fi
            
            # If it's Built-in but not Headphones, it's definitely speakers
            if echo "$OUTPUT_INFO" | grep -q "Transport: Built-in" && ! echo "$OUTPUT_INFO" | grep -Ei "Headphone" > /dev/null; then
                echo "Built-in speakers detected, SHOULD_PLAY is false" >> "$PROJECT_DIR/pocket_say.log"
                SHOULD_PLAY=false
            fi
        fi

        if [ "$SHOULD_PLAY" = true ]; then
            echo "SHOULD_PLAY is true, calling afplay" >> "$PROJECT_DIR/pocket_say.log"
            if afplay "$TEMP_WAV"; then
                echo "afplay successful" >> "$PROJECT_DIR/pocket_say.log"
                rm "$TEMP_WAV"
            else
                echo "afplay failed. The temporary file is at: $TEMP_WAV" >> "$PROJECT_DIR/pocket_say.log"
                cat "$TEMP_WAV" >> "$PROJECT_DIR/pocket_say.log"
                EXIT_CODE=1
            fi
        else
            echo "SHOULD_PLAY is false, not calling afplay" >> "$PROJECT_DIR/pocket_say.log"
        fi
    else
        echo "TEMP_WAV is empty" >> "$PROJECT_DIR/pocket_say.log"
        EXIT_CODE=1
    fi
else
    echo "PLAY_AUDIO is false, saving to $OUTPUT_FILE" >> "$PROJECT_DIR/pocket_say.log"
fi

echo "Exiting with code $EXIT_CODE" >> "$PROJECT_DIR/pocket_say.log"
exit $EXIT_CODE
